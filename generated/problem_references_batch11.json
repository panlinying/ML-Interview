[
  {
    "problem_number": 39,
    "problem_id": "lc-combination-sum",
    "title": "Combination Sum",
    "slug": "combination-sum",
    "solution_code": "from typing import List\n\nclass Solution:\n    def combinationSum(self, candidates: List[int], target: int) -> List[List[int]]:\n        result = []\n\n        def backtrack(start, path, remaining):\n            if remaining == 0:\n                result.append(path[:])\n                return\n            if remaining < 0:\n                return\n            for i in range(start, len(candidates)):\n                path.append(candidates[i])\n                backtrack(i, path, remaining - candidates[i])\n                path.pop()\n\n        backtrack(0, [], target)\n        return result",
    "optimal_time_complexity": "O(N * 2^T)",
    "optimal_space_complexity": "O(T)"
  },
  {
    "problem_number": 40,
    "problem_id": "lc-combination-sum-ii",
    "title": "Combination Sum II",
    "slug": "combination-sum-ii",
    "solution_code": "from typing import List\n\nclass Solution:\n    def combinationSum2(self, candidates: List[int], target: int) -> List[List[int]]:\n        candidates.sort()\n        result = []\n\n        def backtrack(start, path, remaining):\n            if remaining == 0:\n                result.append(path[:])\n                return\n            if remaining < 0:\n                return\n            prev = None\n            for i in range(start, len(candidates)):\n                if prev is not None and candidates[i] == prev:\n                    continue\n                if candidates[i] > remaining:\n                    break\n                prev = candidates[i]\n                path.append(candidates[i])\n                backtrack(i + 1, path, remaining - candidates[i])\n                path.pop()\n\n        backtrack(0, [], target)\n        return result",
    "optimal_time_complexity": "O(N * 2^N)",
    "optimal_space_complexity": "O(N)"
  },
  {
    "problem_number": 79,
    "problem_id": "lc-word-search",
    "title": "Word Search",
    "slug": "word-search",
    "solution_code": "from typing import List\n\nclass Solution:\n    def exist(self, board: List[List[str]], word: str) -> bool:\n        rows, cols = len(board), len(board[0])\n\n        def dfs(r, c, idx):\n            if idx == len(word):\n                return True\n            if r < 0 or r >= rows or c < 0 or c >= cols:\n                return False\n            if board[r][c] != word[idx]:\n                return False\n            temp = board[r][c]\n            board[r][c] = '#'\n            found = (\n                dfs(r + 1, c, idx + 1)\n                or dfs(r - 1, c, idx + 1)\n                or dfs(r, c + 1, idx + 1)\n                or dfs(r, c - 1, idx + 1)\n            )\n            board[r][c] = temp\n            return found\n\n        for r in range(rows):\n            for c in range(cols):\n                if dfs(r, c, 0):\n                    return True\n        return False",
    "optimal_time_complexity": "O(m * n * 4^L)",
    "optimal_space_complexity": "O(L)"
  },
  {
    "problem_number": 131,
    "problem_id": "lc-palindrome-partitioning",
    "title": "Palindrome Partitioning",
    "slug": "palindrome-partitioning",
    "solution_code": "from typing import List\n\nclass Solution:\n    def partition(self, s: str) -> List[List[str]]:\n        result = []\n        n = len(s)\n\n        def is_pal(left, right):\n            while left < right:\n                if s[left] != s[right]:\n                    return False\n                left += 1\n                right -= 1\n            return True\n\n        def backtrack(start, path):\n            if start == n:\n                result.append(path[:])\n                return\n            for end in range(start, n):\n                if is_pal(start, end):\n                    path.append(s[start:end + 1])\n                    backtrack(end + 1, path)\n                    path.pop()\n\n        backtrack(0, [])\n        return result",
    "optimal_time_complexity": "O(n * 2^n)",
    "optimal_space_complexity": "O(n)"
  },
  {
    "problem_number": 51,
    "problem_id": "lc-n-queens",
    "title": "N-Queens",
    "slug": "n-queens",
    "solution_code": "from typing import List\n\nclass Solution:\n    def solveNQueens(self, n: int) -> List[List[str]]:\n        result = []\n        cols = set()\n        diag1 = set()\n        diag2 = set()\n        board = [['.'] * n for _ in range(n)]\n\n        def backtrack(r):\n            if r == n:\n                result.append([''.join(row) for row in board])\n                return\n            for c in range(n):\n                if c in cols or (r - c) in diag1 or (r + c) in diag2:\n                    continue\n                cols.add(c)\n                diag1.add(r - c)\n                diag2.add(r + c)\n                board[r][c] = 'Q'\n                backtrack(r + 1)\n                board[r][c] = '.'\n                cols.remove(c)\n                diag1.remove(r - c)\n                diag2.remove(r + c)\n\n        backtrack(0)\n        return result",
    "optimal_time_complexity": "O(n!)",
    "optimal_space_complexity": "O(n)"
  }
]
