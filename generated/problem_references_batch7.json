[
  {
    "problem_number": 300,
    "problem_id": "lc-longest-increasing-subsequence",
    "title": "Longest Increasing Subsequence",
    "slug": "longest-increasing-subsequence",
    "solution_code": "from typing import List\nimport bisect\n\nclass Solution:\n    def lengthOfLIS(self, nums: List[int]) -> int:\n        tails = []\n        for num in nums:\n            idx = bisect.bisect_left(tails, num)\n            if idx == len(tails):\n                tails.append(num)\n            else:\n                tails[idx] = num\n        return len(tails)",
    "optimal_time_complexity": "O(n log n)",
    "optimal_space_complexity": "O(n)"
  },
  {
    "problem_number": 139,
    "problem_id": "lc-word-break",
    "title": "Word Break",
    "slug": "word-break",
    "solution_code": "from typing import List\n\nclass Solution:\n    def wordBreak(self, s: str, wordDict: List[str]) -> bool:\n        word_set = set(wordDict)\n        n = len(s)\n        dp = [False] * (n + 1)\n        dp[0] = True\n        for i in range(1, n + 1):\n            for j in range(i):\n                if dp[j] and s[j:i] in word_set:\n                    dp[i] = True\n                    break\n        return dp[n]",
    "optimal_time_complexity": "O(n^2)",
    "optimal_space_complexity": "O(n)"
  },
  {
    "problem_number": 416,
    "problem_id": "lc-partition-equal-subset-sum",
    "title": "Partition Equal Subset Sum",
    "slug": "partition-equal-subset-sum",
    "solution_code": "from typing import List\n\nclass Solution:\n    def canPartition(self, nums: List[int]) -> bool:\n        total = sum(nums)\n        if total % 2:\n            return False\n        target = total // 2\n        dp = [False] * (target + 1)\n        dp[0] = True\n        for num in nums:\n            for s in range(target, num - 1, -1):\n                dp[s] = dp[s] or dp[s - num]\n        return dp[target]",
    "optimal_time_complexity": "O(n * target)",
    "optimal_space_complexity": "O(target)"
  },
  {
    "problem_number": 494,
    "problem_id": "lc-target-sum",
    "title": "Target Sum",
    "slug": "target-sum",
    "solution_code": "from typing import List\nfrom collections import defaultdict\n\nclass Solution:\n    def findTargetSumWays(self, nums: List[int], target: int) -> int:\n        total = sum(nums)\n        if (total + target) % 2 != 0 or abs(target) > total:\n            return 0\n        subset = (total + target) // 2\n        dp = [0] * (subset + 1)\n        dp[0] = 1\n        for num in nums:\n            for s in range(subset, num - 1, -1):\n                dp[s] += dp[s - num]\n        return dp[subset]",
    "optimal_time_complexity": "O(n * subset)",
    "optimal_space_complexity": "O(subset)"
  },
  {
    "problem_number": 152,
    "problem_id": "lc-maximum-product-subarray",
    "title": "Maximum Product Subarray",
    "slug": "maximum-product-subarray",
    "solution_code": "from typing import List\n\nclass Solution:\n    def maxProduct(self, nums: List[int]) -> int:\n        max_here = nums[0]\n        min_here = nums[0]\n        best = nums[0]\n        for num in nums[1:]:\n            if num < 0:\n                max_here, min_here = min_here, max_here\n            max_here = max(num, max_here * num)\n            min_here = min(num, min_here * num)\n            best = max(best, max_here)\n        return best",
    "optimal_time_complexity": "O(n)",
    "optimal_space_complexity": "O(1)"
  },
  {
    "problem_number": 309,
    "problem_id": "lc-best-time-to-buy-and-sell-stock-with-cooldown",
    "title": "Best Time Buy Sell with Cooldown",
    "slug": "best-time-to-buy-and-sell-stock-with-cooldown",
    "solution_code": "from typing import List\n\nclass Solution:\n    def maxProfit(self, prices: List[int]) -> int:\n        hold = float('-inf')\n        sold = 0\n        rest = 0\n        for price in prices:\n            prev_sold = sold\n            sold = hold + price\n            hold = max(hold, rest - price)\n            rest = max(rest, prev_sold)\n        return max(sold, rest)",
    "optimal_time_complexity": "O(n)",
    "optimal_space_complexity": "O(1)"
  },
  {
    "problem_number": 312,
    "problem_id": "lc-burst-balloons",
    "title": "Burst Balloons",
    "slug": "burst-balloons",
    "solution_code": "from typing import List\n\nclass Solution:\n    def maxCoins(self, nums: List[int]) -> int:\n        vals = [1] + [n for n in nums if n > 0] + [1]\n        n = len(vals)\n        dp = [[0] * n for _ in range(n)]\n        for length in range(2, n):\n            for left in range(0, n - length):\n                right = left + length\n                best = 0\n                for k in range(left + 1, right):\n                    best = max(best, vals[left] * vals[k] * vals[right] + dp[left][k] + dp[k][right])\n                dp[left][right] = best\n        return dp[0][n - 1]",
    "optimal_time_complexity": "O(n^3)",
    "optimal_space_complexity": "O(n^2)"
  },
  {
    "problem_number": 743,
    "problem_id": "lc-network-delay-time",
    "title": "Network Delay Time",
    "slug": "network-delay-time",
    "solution_code": "from typing import List\nimport heapq\n\nclass Solution:\n    def networkDelayTime(self, times: List[List[int]], n: int, k: int) -> int:\n        graph = [[] for _ in range(n + 1)]\n        for u, v, w in times:\n            graph[u].append((v, w))\n\n        dist = [float('inf')] * (n + 1)\n        dist[k] = 0\n        heap = [(0, k)]\n        while heap:\n            d, node = heapq.heappop(heap)\n            if d > dist[node]:\n                continue\n            for nei, w in graph[node]:\n                nd = d + w\n                if nd < dist[nei]:\n                    dist[nei] = nd\n                    heapq.heappush(heap, (nd, nei))\n\n        max_dist = max(dist[1:])\n        return -1 if max_dist == float('inf') else max_dist",
    "optimal_time_complexity": "O((n + e) log n)",
    "optimal_space_complexity": "O(n + e)"
  },
  {
    "problem_number": 787,
    "problem_id": "lc-cheapest-flights-within-k-stops",
    "title": "Cheapest Flights Within K Stops",
    "slug": "cheapest-flights-within-k-stops",
    "solution_code": "from typing import List\n\nclass Solution:\n    def findCheapestPrice(self, n: int, flights: List[List[int]], src: int, dst: int, k: int) -> int:\n        dist = [float('inf')] * n\n        dist[src] = 0\n        for _ in range(k + 1):\n            tmp = dist[:]\n            for u, v, w in flights:\n                if dist[u] == float('inf'):\n                    continue\n                if dist[u] + w < tmp[v]:\n                    tmp[v] = dist[u] + w\n            dist = tmp\n        return -1 if dist[dst] == float('inf') else dist[dst]",
    "optimal_time_complexity": "O(k * e)",
    "optimal_space_complexity": "O(n)"
  },
  {
    "problem_number": 684,
    "problem_id": "lc-redundant-connection",
    "title": "Redundant Connection",
    "slug": "redundant-connection",
    "solution_code": "from typing import List\n\nclass Solution:\n    def findRedundantConnection(self, edges: List[List[int]]) -> List[int]:\n        parent = list(range(len(edges) + 1))\n        rank = [0] * (len(edges) + 1)\n\n        def find(x):\n            while parent[x] != x:\n                parent[x] = parent[parent[x]]\n                x = parent[x]\n            return x\n\n        def union(a, b):\n            ra, rb = find(a), find(b)\n            if ra == rb:\n                return False\n            if rank[ra] < rank[rb]:\n                ra, rb = rb, ra\n            parent[rb] = ra\n            if rank[ra] == rank[rb]:\n                rank[ra] += 1\n            return True\n\n        for u, v in edges:\n            if not union(u, v):\n                return [u, v]\n        return []",
    "optimal_time_complexity": "O(n * alpha(n))",
    "optimal_space_complexity": "O(n)"
  }
]
