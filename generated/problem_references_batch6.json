[
  {
    "problem_number": 647,
    "problem_id": "lc-palindromic-substrings",
    "title": "Palindromic Substrings",
    "slug": "palindromic-substrings",
    "solution_code": "class Solution:\n    def countSubstrings(self, s: str) -> int:\n        n = len(s)\n        count = 0\n\n        def expand(left, right):\n            nonlocal count\n            while left >= 0 and right < n and s[left] == s[right]:\n                count += 1\n                left -= 1\n                right += 1\n\n        for i in range(n):\n            expand(i, i)\n            expand(i, i + 1)\n\n        return count",
    "optimal_time_complexity": "O(n^2)",
    "optimal_space_complexity": "O(1)"
  },
  {
    "problem_number": 91,
    "problem_id": "lc-decode-ways",
    "title": "Decode Ways",
    "slug": "decode-ways",
    "solution_code": "class Solution:\n    def numDecodings(self, s: str) -> int:\n        if not s or s[0] == '0':\n            return 0\n        prev2 = 1\n        prev1 = 1\n        for i in range(1, len(s)):\n            curr = 0\n            if s[i] != '0':\n                curr += prev1\n            two = int(s[i - 1:i + 1])\n            if 10 <= two <= 26:\n                curr += prev2\n            prev2, prev1 = prev1, curr\n        return prev1",
    "optimal_time_complexity": "O(n)",
    "optimal_space_complexity": "O(1)"
  },
  {
    "problem_number": 62,
    "problem_id": "lc-unique-paths",
    "title": "Unique Paths",
    "slug": "unique-paths",
    "solution_code": "class Solution:\n    def uniquePaths(self, m: int, n: int) -> int:\n        dp = [1] * n\n        for _ in range(1, m):\n            for j in range(1, n):\n                dp[j] += dp[j - 1]\n        return dp[-1]",
    "optimal_time_complexity": "O(m * n)",
    "optimal_space_complexity": "O(n)"
  },
  {
    "problem_number": 63,
    "problem_id": "lc-unique-paths-ii",
    "title": "Unique Paths II",
    "slug": "unique-paths-ii",
    "solution_code": "from typing import List\n\nclass Solution:\n    def uniquePathsWithObstacles(self, obstacleGrid: List[List[int]]) -> int:\n        if not obstacleGrid or not obstacleGrid[0]:\n            return 0\n        m, n = len(obstacleGrid), len(obstacleGrid[0])\n        dp = [0] * n\n        dp[0] = 1 if obstacleGrid[0][0] == 0 else 0\n        for i in range(m):\n            for j in range(n):\n                if obstacleGrid[i][j] == 1:\n                    dp[j] = 0\n                elif j > 0:\n                    dp[j] += dp[j - 1]\n        return dp[-1]",
    "optimal_time_complexity": "O(m * n)",
    "optimal_space_complexity": "O(n)"
  },
  {
    "problem_number": 64,
    "problem_id": "lc-minimum-path-sum",
    "title": "Minimum Path Sum",
    "slug": "minimum-path-sum",
    "solution_code": "from typing import List\n\nclass Solution:\n    def minPathSum(self, grid: List[List[int]]) -> int:\n        m, n = len(grid), len(grid[0])\n        dp = [0] * n\n        dp[0] = grid[0][0]\n        for j in range(1, n):\n            dp[j] = dp[j - 1] + grid[0][j]\n        for i in range(1, m):\n            dp[0] += grid[i][0]\n            for j in range(1, n):\n                dp[j] = min(dp[j], dp[j - 1]) + grid[i][j]\n        return dp[-1]",
    "optimal_time_complexity": "O(m * n)",
    "optimal_space_complexity": "O(n)"
  },
  {
    "problem_number": 72,
    "problem_id": "lc-edit-distance",
    "title": "Edit Distance",
    "slug": "edit-distance",
    "solution_code": "class Solution:\n    def minDistance(self, word1: str, word2: str) -> int:\n        m, n = len(word1), len(word2)\n        if m < n:\n            word1, word2 = word2, word1\n            m, n = n, m\n\n        prev = list(range(n + 1))\n        for i in range(1, m + 1):\n            curr = [i] + [0] * n\n            for j in range(1, n + 1):\n                if word1[i - 1] == word2[j - 1]:\n                    curr[j] = prev[j - 1]\n                else:\n                    curr[j] = 1 + min(prev[j - 1], prev[j], curr[j - 1])\n            prev = curr\n        return prev[-1]",
    "optimal_time_complexity": "O(m * n)",
    "optimal_space_complexity": "O(n)"
  },
  {
    "problem_number": 1143,
    "problem_id": "lc-longest-common-subsequence",
    "title": "Longest Common Subsequence",
    "slug": "longest-common-subsequence",
    "solution_code": "class Solution:\n    def longestCommonSubsequence(self, text1: str, text2: str) -> int:\n        m, n = len(text1), len(text2)\n        dp = [0] * (n + 1)\n        for i in range(1, m + 1):\n            prev_diag = 0\n            for j in range(1, n + 1):\n                temp = dp[j]\n                if text1[i - 1] == text2[j - 1]:\n                    dp[j] = prev_diag + 1\n                else:\n                    dp[j] = max(dp[j], dp[j - 1])\n                prev_diag = temp\n        return dp[-1]",
    "optimal_time_complexity": "O(m * n)",
    "optimal_space_complexity": "O(n)"
  },
  {
    "problem_number": 97,
    "problem_id": "lc-interleaving-string",
    "title": "Interleaving String",
    "slug": "interleaving-string",
    "solution_code": "class Solution:\n    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:\n        if len(s1) + len(s2) != len(s3):\n            return False\n        if len(s2) > len(s1):\n            s1, s2 = s2, s1\n\n        dp = [False] * (len(s2) + 1)\n        dp[0] = True\n        for j in range(1, len(s2) + 1):\n            dp[j] = dp[j - 1] and s2[j - 1] == s3[j - 1]\n\n        for i in range(1, len(s1) + 1):\n            dp[0] = dp[0] and s1[i - 1] == s3[i - 1]\n            for j in range(1, len(s2) + 1):\n                dp[j] = (dp[j] and s1[i - 1] == s3[i + j - 1]) or (dp[j - 1] and s2[j - 1] == s3[i + j - 1])\n        return dp[-1]",
    "optimal_time_complexity": "O(m * n)",
    "optimal_space_complexity": "O(n)"
  },
  {
    "problem_number": 322,
    "problem_id": "lc-coin-change",
    "title": "Coin Change",
    "slug": "coin-change",
    "solution_code": "from typing import List\n\nclass Solution:\n    def coinChange(self, coins: List[int], amount: int) -> int:\n        dp = [amount + 1] * (amount + 1)\n        dp[0] = 0\n        for coin in coins:\n            for x in range(coin, amount + 1):\n                dp[x] = min(dp[x], dp[x - coin] + 1)\n        return dp[amount] if dp[amount] != amount + 1 else -1",
    "optimal_time_complexity": "O(n * amount)",
    "optimal_space_complexity": "O(amount)"
  },
  {
    "problem_number": 518,
    "problem_id": "lc-coin-change-ii",
    "title": "Coin Change II",
    "slug": "coin-change-ii",
    "solution_code": "from typing import List\n\nclass Solution:\n    def change(self, amount: int, coins: List[int]) -> int:\n        dp = [0] * (amount + 1)\n        dp[0] = 1\n        for coin in coins:\n            for x in range(coin, amount + 1):\n                dp[x] += dp[x - coin]\n        return dp[amount]",
    "optimal_time_complexity": "O(n * amount)",
    "optimal_space_complexity": "O(amount)"
  }
]
